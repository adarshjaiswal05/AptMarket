// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.1;

import "./APT721.sol";

import "./APT1155.sol";

contract CommonMarket  {

    struct AssetDetails {
        uint256 tokenType;
        string url;
        uint256 biddingPrice;
        uint256 salePrice;
        uint256 quantityOnSale;
        uint256 quantityOnBidding;
        uint256 remainingQuantity;
    }

    APT721 private _erc721;
    APT1155 private _erc1155;
    address private _admin;
    address private _pendingAdmin;
    uint256 private tokenId721=0;
    uint256 private tokenId1155=0;
    
    mapping(string => uint) public _uriId;
//do it private
    mapping(uint256 => AssetDetails) public _assetId721;
//do it private
    mapping(uint256 => AssetDetails) public _assetId1155;

    mapping(address => uint256) public  _addressAccumlatedAmount;

    event BoughtNFT(uint256 tokenId, address buyer);

    constructor(APT721 erc721, APT1155 erc1155) {
        //chechking address zero
        require(erc721 != APT721(address(0)), "APT_Market:zero address sent");
        require(erc1155 != APT1155(address(0)), "APT_Market:zero address sent");
        //setting admin to message sender
        _admin = msg.sender;
        _erc721 = erc721;
        _erc1155 = erc1155;
        //setting the market place address in the ERC721 and ERC1155 contract
        _erc721.setMarketAddress();
        _erc1155.setMarketAddress();
    }

    function mintAdmin(
        address to,
        string memory tokenUri,
        uint256 quantity
    ) external {
        require(msg.sender==_admin ,"APT_Market: Only admin is allowed to mint");
        require(quantity>0, "APT_Market: Invalid quantity");
        require( _uriId[tokenUri] !=0 ,"APT_Market: Token uri already exists");
        
        // uint token;

        if (quantity==1) {
            tokenId721++;
            _erc721.mint(to,tokenUri,tokenId721);
            _uriId[tokenUri]=tokenId721;

        } else {
            tokenId1155++;
           _erc1155.mint(to, quantity,tokenUri,tokenId1155);
           _uriId[tokenUri]=tokenId1155;
        }
        
    }


    function mintUser(
        string memory tokenUri,
        uint256 quantity
        )
        external {
            require(quantity>0, "APT_Market:Invalid quantity");
            require( _uriId[tokenUri] == 0 ,"APT_Market: Token uri already exists");
            // uint token;
            
        AssetDetails memory newAsset;
     
            if (quantity==1) {        
             tokenId721++;
             _erc721.mint(msg.sender,tokenUri,tokenId721);
             newAsset.tokenType = 721;
             newAsset.url = tokenUri;
             newAsset.remainingQuantity = quantity;
             _assetId721[tokenId721] = newAsset;
             _uriId[tokenUri]=tokenId721;

            } else {
                tokenId1155++;
                _erc1155.mint(msg.sender, quantity,tokenUri,tokenId1155);
                newAsset.tokenType = 1155;
                newAsset.url = tokenUri;
                newAsset.remainingQuantity = quantity;
                _assetId1155[tokenId1155] = newAsset;
                _uriId[tokenUri]=tokenId1155;
            }
            
        }



    function setOnSale(
        string memory tokenUri,
        uint256 price,
        uint256 quantity
    ) external {
        uint256 tokenId= _uriId[tokenUri];

        require(price > 0, "please set a valid price");
        
        require( _assetId721[tokenId].tokenType == 721 || _assetId1155[tokenId].tokenType == 1155 , "invalid token URI");
        
        if(keccak256(abi.encodePacked((_assetId721[tokenId].url))) == keccak256(abi.encodePacked((tokenUri)))) {
            //this means that token type is 721
            require(_assetId721[tokenId].quantityOnSale == 0,"721:sale created alredy ");
            require(
                quantity <= _assetId721[tokenId].remainingQuantity,
                "721:No enough tokens left for sale"
            );
            require(quantity == 1, "721:only one token available for type 721");

        _assetId721[tokenId].quantityOnSale += quantity;
        _assetId721[tokenId].remainingQuantity -= quantity;
        _assetId721[tokenId].salePrice = price;

        }else {
            //this means that token type is 1155
            require(_assetId1155[tokenId].quantityOnSale == 0,"1155:sale created alredy ");
            
            require(
                quantity <= _assetId1155[tokenId].remainingQuantity,
                "1155:No enough tokens left for sale"
            );
            require(
                _erc1155.balanceOf(msg.sender, tokenId) >= quantity,
                "1155:Owner dosent have enough tokens "
            );

        _assetId1155[tokenId].quantityOnSale += quantity;
        _assetId1155[tokenId].remainingQuantity -= quantity;
        _assetId1155[tokenId].salePrice = price;
        } 
    }

     function removeFromSale( string memory tokenUri) external {
         uint256 tokenId= _uriId[tokenUri];
          require( _assetId721[tokenId].tokenType == 721 || _assetId1155[tokenId].tokenType == 1155 , "invalid token URI");
              if(keccak256(abi.encodePacked((_assetId721[tokenId].url))) == keccak256(abi.encodePacked((tokenUri)))) {
                require(_assetId721[tokenId].quantityOnSale != 0,"721:No sale found");
                 onlyOwner(721 , tokenId, msg.sender);
                _assetId721[tokenId].remainingQuantity += _assetId721[tokenId].quantityOnSale;
                _assetId721[tokenId].quantityOnSale = 0;
                _assetId721[tokenId].salePrice  = 0;

              }else{
                require(_assetId1155[tokenId].quantityOnSale != 0,"721:No sale found");
                 onlyOwner(1155 , tokenId, msg.sender);
                _assetId1155[tokenId].remainingQuantity += _assetId1155[tokenId].quantityOnSale;
                _assetId1155[tokenId].quantityOnSale = 0;
                _assetId1155[tokenId].salePrice  = 0;
              }

    }


      //reentracy attack proof
    function buyImage(
        address owner,
        string memory tokenUri
    ) external payable {
        uint tokenId=_uriId[tokenUri];
        require( _assetId721[tokenId].tokenType == 721 || _assetId1155[tokenId].tokenType == 1155 , "invalid token ID");
           
           if(keccak256(abi.encodePacked((_assetId721[tokenId].url))) == keccak256(abi.encodePacked((tokenUri)))) {
            uint256 saleQuantity = _assetId721[tokenId].quantityOnSale;
            require(saleQuantity != 0, "This token has not been listed on sale");
            require(
            msg.value == _assetId721[tokenId].salePrice+500,
            "please enter valid price to buy nft "
             );

            saleQuantityCheck721(tokenId);
            _addressAccumlatedAmount[owner] += msg.value;
            _sendERC721(owner, msg.sender, tokenId);

           }
           else{
            uint256 saleQuantity = _assetId1155[tokenId].quantityOnSale;
            require(saleQuantity != 0, "This token has not been listed on sale");
            require(
            msg.value == _assetId1155[tokenId].salePrice,
            "please enter valid price to buy nft "
             );
             saleQuantityCheck1155(tokenId);
            _addressAccumlatedAmount[owner] += msg.value; 
            _sendERC1155(owner, msg.sender, tokenId, saleQuantity);
           }
           
        emit BoughtNFT(tokenId, msg.sender);

        }

    function withdrawAccumlatedAmount(uint256 amount) external {
        require(amount > 0, "Please withdraw some amount");
        require(
            _addressAccumlatedAmount[msg.sender] >= amount,
            "you have entered wrong amount"
        );
        _addressAccumlatedAmount[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
    }
      
   
    function saleQuantityCheck721(uint256 tokenId) private {
        //this is for reentrency data updating
        if (
            _assetId721[tokenId].remainingQuantity +
                _assetId721[tokenId].quantityOnBidding ==
            0
        ) {
            delete _assetId721[tokenId];
        } else {
            _assetId721[tokenId].quantityOnSale = 0;
            _assetId721[tokenId].salePrice =0;
        }
    }

    function saleQuantityCheck1155(uint256 tokenId) private {
        //this is for reentrency data updating
        if (
            _assetId1155[tokenId].remainingQuantity +
                _assetId1155[tokenId].quantityOnBidding ==
            0
        ) {
            delete _assetId1155[tokenId];
        } else {
            _assetId1155[tokenId].quantityOnSale = 0;
             _assetId1155[tokenId].salePrice=0;
         }
    }
    


    function onlyOwner(
        uint256 tokenType,
        uint256 tokenId,
        address owner
    ) private view {
        if (tokenType == 721) {
            require(_erc721.ownerOf(tokenId) == owner, "invalid owner");
        } else if (tokenType == 1155) {
            require(
                _erc1155.balanceOf(owner, tokenId) != 0,
                "wrong owner, token type or token id"
            );
        }
    }



    function changeOwnership(address newAdmin)external {
        require(msg.sender==_admin,"APT_Market:Only admin is allowed to call this function");
        _pendingAdmin=newAdmin;  
    }

    function acceptOwnership()external {
        require(msg.sender==_pendingAdmin,"APT_Market:You are forbidden to call");
        _admin=_pendingAdmin;
    }

    function _sendERC721(
        address owner,
        address to,
        uint256 tokenId
    ) private {
        _erc721.safeTransferFrom(owner, to, tokenId);
    }
    function _sendERC1155(
        address owner,
        address to,
        uint256 tokenId,
        uint256 quantity
    ) private {
        _erc1155.safeTransferFrom(owner, to, tokenId, quantity, "");
    }
    }
